import discord, asyncio, aiohttp, json, time, jsonpickle
from concurrent.futures import ProcessPoolExecutor, Future
from collections import deque

class Harvestor:


    def __init__(self):

        self.client = discord.Client()
        self.setup()

    def setup(self):

        @self.client.event
        @asyncio.coroutine
        async def on_ready():
            print('Logged in as')
            print(self.client.user.name + "\n" + self.client.user.id + "\n--------")



        @self.client.event
        @asyncio.coroutine
        async def on_message(message):
            channel = message.channel
            print(channel.name, channel.id)
            await get_messages(channel)
            #await self.client.send_message(channel, "GIT REKT SCRUB!! Channel name, channel id: " + channel.name + "   " + channel.id)


        @self.client.event
        @asyncio.coroutine
        async def get_messages(channel):

            messages = {}
            with open("ufwm-dump.json", "w") as f:
                async for m in self.client.logs_from(channel, limit=10000):
                        data = MessageData(m.timestamp, m.author, m.content, m.id)
                        messages[m.id] = data.__dict__
                json.dump(messages, f, default=str)


        self.run()

    def get_all_messages(self, channel):
        logs = yield from self.client.logs_from(channel, limit=10000)
        print(logs)
        for message in logs:
            print(message.content)

    def run(self):

        try:
            self.client.run(r"NTA5NjYzOTAzNjgxMjE2NTE1.DsRFKA.oATEMya7q3nrdazJAMCwZ-fYwNc")
        except Exception:
            pass

class MessageData:

    def __init__(self, timestamp, author, content, messageID):
        self.timestamp = timestamp
        self.author = author
        self.content = content
        self.messageID = messageID

if __name__ == '__main__':
    myobj = Harvestor()
