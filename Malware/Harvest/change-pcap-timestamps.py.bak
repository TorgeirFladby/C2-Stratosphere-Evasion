import time, sys, os, random
from scapy.all import *
from collections import deque
from adaptive_random_search import PerturbationOptimizer
import md5
from spsa_slips import *


#zbot = rdpcap("/Users/torgeirfladby/Documents/Masteroppgave/netfiles/2014-02-07_capture-win3-edited.pcap")
cridex = rdpcap("/Users/torgeirfladby/Documents/Masteroppgave/netfiles/2015-03-09_capture-win7-first1k.pcap")
#wrpcap("2016-01-12-capture_win7-modified.pcap", newpcap)


class Flow:
    def __init__(self, init_packet):
        self.t1 = init_packet.time
        self.t2 = None
        self.td = None

        self.length = len(init_packet)

        self.src_ip = init_packet[IP].src
        self.dst_ip = init_packet[IP].dst
        self.src_port = None
        self.dst_port = None
        self.src_port = init_packet[IP].sport
        self.dst_port = init_packet[IP].dport
        self.ToS = None
        self.packets = []
        self.packets.append(init_packet)
        self.td_list = []
        self.td_fractions = []


    def get_td(self):
        return self.td

    # Obsolete because we compare the hash :)
    def belongs_in_flow(self, packet):
        return packet[IP].src == self.src_ip and packet[IP].dst == self.dst_ip and packet[IP].sport == self.src_port and packet[IP].dport == self.dst_port

    def add_to_flow(self, packet):
        self.packets.append(packet)
        self.length += len(packet)

    def add_to_flow_not_IP(self, packet):
        self.packets.append(packet)

    def set_flow(self):
        self.t1 = self.packets[0].time
        self.t2 = self.packets[-1].time
        self.td = self.t2 - self.t1

    def set_timedeltas(self):
        if len(self.packets) > 1 and self.td != None:
            counter = 0
            for packet in self.packets[1:]:
                self.td_list.append(packet.time - self.packets[counter].time)
                self.td_fractions.append(self.td_list[counter]/self.td)
                counter +=1
    def perturb_duration(self, perturbation):
        """
        We receive a perturbation parameter for this flow.
        Can be positive or negative, but should ultimately affect the time-delta value of this flow.

        1. Decide how to distribute perturbation load over the different packets.
            1.1 time-deltas are computed and the duration is distributed evenly over the different connections.
        2. To perturb the first td, td1 -> td1^p, set timestamp t1 = t1 + (pert*tdp1)
        3. Should also take offline_duration as parameter


        FIX THIS:
        when subtracting duration, we must subtract time from all connections in the flow. figure out a better way to do this.
        """
        counter = 1
        pert_sum = 0

        old = self.t2
        pert_seconds = perturbation - self.td
        print "Pert seconds:", pert_seconds
        print "Perturbation:", perturbation
        print "Self.td: ", self.td
        for td_f in self.td_fractions:
            print td_f
            pert = pert_seconds * td_f
            print "Pert:", pert
            pert_sum += pert
            print "Pert sum: ", pert_sum
            if len(self.td_fractions) == counter:
                self.packets[counter].time += pert_seconds
            else:
                self.packets[counter].time += pert_sum
            counter +=1

        print "Old duration:\t", self.td
        self.set_flow()
        print "New duration:\t", self.td
        return pert_seconds

    def incr_timestamps(self, incr, offline_duration):
        default_incr = incr + offline_duration
        prev_time = self.packets[-1].time
        for packet in self.packets:
            packet.time += default_incr

        print "The last packet in this flow was changed from time: %f to %f" % (prev_time, self.packets[-1].time)
        self.set_flow()
        return self.packets[-1].time - prev_time


    def __str__(self):
        return str(self.src_ip) + "\t" + str(self.src_port) + "\t" + str(self.dst_ip) + "\t" +  str(self.dst_port)


perturbator = PerturbationOptimizer()

def parse_pcap(packets):
    """
    Ommitting ARP and IPv6.

    We assume that the attacker knows which IPs are malicious.
    """

    flows = {}

    counter = 0
    for packet in packets[1:]:
        counter +=1
        print counter
        if IP in packet:
            packet_id = md5.new(str(packet[IP].src) + str(packet[IP].dst) + str(packet[IP].sport) + str(packet[IP].dport)).digest()
            if packet_id in flows.keys():
                flows[packet_id].add_to_flow(packet)
            else:
                flows[packet_id] = Flow(packet)
        elif ARP in packet:
            packet_id = md5.new(str(packet[ARP].hwsrc) + str(packet[ARP].hwdst) + str(packet.time))
            flows[packet_id] = packet
        elif IPv6 in packet:
            packet_id = md5.new(str(packet[IPv6].src) + str(packet[IPv6].dst) + str(packet.time))
            flows[packet_id] = packet

    counter = 0
    for i in flows.keys():
        if isinstance(flows[i], Flow):
            flows[i].set_flow()
            flows[i].set_timedeltas()
    print counter

    return flows


def parse_pcap_to_deque(packets):
    """
    Ommitting ARP and IPv6.

    We assume that the attacker knows which IPs are malicious.
    """

    flows = deque()

    counter = 0
    for packet in packets[1:]:
        counter +=1
        added_to_flow = False
        if IP in packet:
            for flow in flows:
                if isinstance(flow, Flow):
                    if flow.belongs_in_flow(packet):
                        flow.add_to_flow(packet)
                        added_to_flow = True
            if not added_to_flow:
                flows.append(Flow(packet))
        else:
            flows.append(packet)

    counter = 0
    for i in flows:
        if isinstance(i, Flow):
            i.set_flow()
            i.set_timedeltas()

    return flows

def measure_offline_duration(target_tuple):
    flows = parse_pcap_to_deque(cridex)

    offline_durations = []
    actual_durations = []
    new_flow = True
    for flow in flows:
        if isinstance(flow, Flow):
            if(flow.src_ip, flow.dst_ip) in [target_tuple]:
                if len(offline_durations) == 0 or new_flow:
                    offline_durations.append((flow.packets[-1].time,))
                    new_flow = False
                elif not new_flow:
                    offline_durations[-1] += (flow.packets[0].time, )
                    new_flow = True
                #print offline_durations[-1]
    for i in offline_durations:
        if len(i) > 1:
            actual_durations.append(i[1]-i[0])

    return actual_durations

def redefine_stored_network_flows(target_tuples):

    flows = parse_pcap_to_deque(cridex)

    perts = get_perturbation_params()

    incr, timestamp, counter, offline_duration = 0, flows[0].time, 0, 1000

    print "Altering duration of packets..."

    for flow in flows:
        counter = 0
        original_timestamp = 0
        pert = perts.pop()
        if not isinstance(flow, Flow):
            original_timestamp = flow.time
            perts.appendleft(pert)
        else:
            original_timestamp = flow.packets[-1].time

        timestamp = original_timestamp + incr
        if isinstance(flow, Flow):
            if (flow.src_ip, flow.dst_ip) in target_tuples:
                incr = flow.incr_timestamps(incr, 0)
                incr += flow.perturb_duration(pert[1])
                offline_duration = 0
                for packet in flow.packets:
                    wrpcap("2015-03-09-1k-modded-no-offline.pcap", packet, append=True)
            else:
                flow.incr_timestamps(incr, 0)
                for packet in flow.packets:
                    wrpcap("2015-03-09-1k-modded-no-offline.pcap", packet, append=True)
        else:
            flow.time = original_timestamp + incr
            wrpcap("2015-03-09-1k-modded-no-offline.pcap", flow, append=True)
        print "Original_timestamp: %f \t increment: %f \t timestamp: %f" % (original_timestamp, incr, timestamp)




def redefine_networkflows(tw_threshold, packets, src, dst):

    incr = 0

    in_flow = False
    t0 = 0
    last_packet_in_flow = packets[1]
    #Initial flow timer value that will cause same_flow()'s first query to return False.
    timestamp = packets[1].time
    counter = 0
    flowcounter = 0
    print(timestamp)
    for packet in packets[1:]:
        #print("Found packet: ", packet.show())
        counter+=1
        actual_timestamp = packet.time
        timestamp = actual_timestamp + incr
        if IP in packet:
            perturbed_params = get_perturbation_params()
            if not in_flow and (packet[IP].src == src[0] and packet[IP].dst == dst[0]):
                # New connection to c2 server. Not in a flow, so start a new flow.
                flowcounter += 1
                t0 = packet.time
                # Increase size of this packet by padding bytes.
                if len(packet) < perturbed_params["vector"][0]:
                    pad_len = perturbed_params["vector"][0] - int(len(packet))
                    print "Padding %d bytes to packet with initial length %d" % (pad_len, len(packet))
                    """
                    pad = '\x00' * int(pad_len)
                    if hasattr(packet[IP], 'load'):
                        packet.load += pad
                    else:
                        packet.load = pad
                    print "New packet length: %d" % (len(packet))
                    """
                timestamp += incr
                #packet.show()
                #print("This packet's IP: %s\t This packet's unmodified timestamp: %s\t This packet's modified timestamp: %s\t Previous packet's modified time: %s\t" % (packet[IP].src, packet.time, timestamp, last_packet_in_flow.time))
                #print("T_0 : ", t0)
                in_flow = True
                last_packet_in_flow = packet
                packet.time = timestamp
            elif in_flow and (packet[IP].src == src[0] and packet[IP].dst == dst[0]):
                incr += perturbed_params["vector"][1]/1000
                timestamp += incr
                # Increase size of this packet by padding bytes.
                if len(packet) < perturbed_params["vector"][0]:
                    pad_len = perturbed_params["vector"][0] - int(len(packet))
                    pad = Padding()
                    pad.load = '\x00' * int(pad_len)
                    #packet = packet/pad
                #print("This packet's IP: %s\t This packet's unmodified timestamp: %s\t This packet's modified timestamp: %s\t Previous packet's modified time: %s\t Previous packet's IP: %s" % (packet[IP].src, packet.time, timestamp, last_packet_in_flow.time, last_packet_in_flow[IP].src))
                #time.sleep(10)
                #print("Incremented from T_0: %d to T_n: %d, incremented by %d", packet.time, timestamp, incr)
                # Check if this flow will exceed the threshold. If so, set flow determinator to False.
                if not same_flow(tw_threshold, t0, packet.time):
                    in_flow = False
                    t0 = packet.time

                last_packet_in_flow = packet
                packet.time = timestamp

            elif not in_flow and (packet[IP].src == src[0] and packet[IP].dst == dst[0]):
                # request is outside flow threshold. Create a new flow and don't increment timer.
                in_flow = True
                # Increase size of this packet by padding bytes.
                if len(packet) < perturbed_params["vector"][0]:
                    pad_len = perturbed_params["vector"][0] - int(len(packet))
                    pad = Padding()
                    pad.load = '\x00' * int(pad_len)
                    #packet = packet/pad
                t0 = packet.time
                timestamp += incr
                #print("This packet's IP: %s\t This packet's unmodified timestamp: %s\t This packet's modified timestamp: %s\t Previous packet's modified time: %s\t Previous packet's IP: %s" % (packet[IP].src, packet.time, timestamp, last_packet_in_flow.time, last_packet_in_flow[IP].src))
                #print("T_0 : ", t0)
                last_packet_in_flow = packet
                packet.time = timestamp
            elif in_flow and (packet[IP].src == dst[0] and packet[IP].dst == src[0]):
                flowcounter += 1
                # Increase size of this packet by padding bytes.
                if len(packet) < perturbed_params["vector"][0]:
                    pad_len = perturbed_params["vector"][0] - int(len(packet))
                    pad = Padding()
                    pad.load = '\x00' * int(pad_len)
                    #packet = packet/pad
                # Increase duration of this connection.
                incr += perturbed_params["vector"][1]/1000
                timestamp += incr
                #print("This packet's IP: %s\t This packet's unmodified timestamp: %s\t This packet's modified timestamp: %s\t Previous packet's modified time: %s\t Previous packet's IP: %s" % (packet[IP].src, packet.time, timestamp, last_packet_in_flow.time, last_packet_in_flow[IP].src))
                #print("Incremented from T_0: %d to T_n: %d, incremented by %d" % (packet.time, timestamp, incr))
                if not same_flow(tw_threshold, t0, packet.time):
                    in_flow = False
                    t0 = packet.time

                last_packet_in_flow = packet
                packet.time = timestamp

            else:
                packet.time = timestamp + incr
                # We did not use these parameters, so put them back in the top of the deque
                perturbator.best_params.appendleft(perturbed_params)
        else:
            packet.time = timestamp + incr
        wrpcap('modified-2014-02-07-edited.pcap', packet, append=True)

def same_flow(tw_threshold, t0, t_n):
    #print("Difference: ", t_n - t0)
    return (t_n - t0) < tw_threshold

def get_perturbation_params():
    """best = perturbator.best_params.pop()
    if best != None:
        return best
    print "Perturbation set was empty. :( Returning default values."
    return [350, 1000, 8000]"""
    pertlist = deque()
    for i in range(250):
        pertlist.append(run_spsa())

    return pertlist

#redefine_networkflows(30, zbot, ['10.0.2.103'], ['8.8.8.8'])

#redefine_stored_network_flows([('10.0.2.107','212.59.117.207'), ('10.0.2.107', '91.222.139.45')])
print measure_offline_duration(('10.0.2.107', '91.222.139.45'))


"""
Using original binetflow file, Slips gives the following output for malicious DNS connections:
    DstIP: 8.8.8.8,
    Label: From-Botnet-UDP-DNS-DGA-17 ,
    Detection Time: 1970-01-01 01:34:18.872789,
    State(100 max): 44.R+R.U.u.a.a.d.a.d.a.a.d.d.a.d.a.a.a.d.a.a.a.a.a.a.a.d.d.a.a.a.a.a.a.a.a.a.a.d.d.a.a.d.a.d.a.a.d.d

Using the binetflow file with modified duration parameters, Slips gives the following output for malicious DNS connections:
    DstIP: 8.8.8.8,
    Label: 0 ,
    Detection Time: 1970-01-01 06:01:46.305854,
    State(100 max): 55,S+S,v,v.s,B,e,s.v,B,B,E,v.B,v.B,s,b,E,B,s,s,s,s,s,B,v,E,s,s,B,s.b.B.s,s,s,s,E,v,s,B,v,B.v,b,s,E,v

    Sjekk ut: Simultaenous perturbation stoachastic approximation


Regarding padding of DNS packets:
    -> Is there a point in adding payload to DNS packets? isn't DNS used just for issuing botnet commands, rather than extracting data?
    -> DNS is only used for looking up domains through DGAs that lookup domains. The domain may contain commands that should be executed.
    -> For that reason, there is no point in padding packets that use DNS for C2 communication.

    -> Padding of packets should be used when there is a TCP connection with a C2 server. Check out the datasets and see if there is traffic that contain TCP traffic.
    -> It is, however, interesting to look at whether perturbation to connection duration, flow duration and offline duration causes DNS traffic to be rendered undetected.

Reviewing the current implementation of the pcap-parser:
- Network flows cannot be defined by a time window.
- Rather, let's define it as requests from a particular source port on a particular source IP to a corresponding IP/port.

Cisco standard NetFlow version 5 defines a flow as a unidirectional sequence of packets that all share the following 7 values:[2]

Ingress interface (SNMP ifIndex)
Source IP address
Destination IP address
IP protocol
Source port for UDP or TCP, 0 for other protocols
Destination port for UDP or TCP, type and code for ICMP, or 0 for other protocols
IP Type of Service

"""
